"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DrawerView;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _reactNativeScreens = require("react-native-screens");

var _reactNativeGestureHandler = require("react-native-gesture-handler");

var _native = require("@react-navigation/native");

var _DrawerGestureContext = _interopRequireDefault(require("../utils/DrawerGestureContext"));

var _SafeAreaProviderCompat = _interopRequireDefault(require("./SafeAreaProviderCompat"));

var _ResourceSavingScene = _interopRequireDefault(require("./ResourceSavingScene"));

var _DrawerContent = _interopRequireDefault(require("./DrawerContent"));

var _Drawer = _interopRequireDefault(require("./Drawer"));

var _DrawerPositionContext = _interopRequireDefault(require("../utils/DrawerPositionContext"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const getDefaultDrawerWidth = (_ref) => {
  let {
    height,
    width
  } = _ref;

  /*
   * Default drawer width is screen width - header height
   * with a max width of 280 on mobile and 320 on tablet
   * https://material.io/guidelines/patterns/navigation-drawer.html
   */
  const smallerAxisSize = Math.min(height, width);
  const isLandscape = width > height;
  const isTablet = smallerAxisSize >= 600;
  const appBarHeight = _reactNative.Platform.OS === 'ios' ? isLandscape ? 32 : 44 : 56;
  const maxWidth = isTablet ? 320 : 280;
  return Math.min(smallerAxisSize - appBarHeight, maxWidth);
};

const GestureHandlerWrapper = _reactNativeGestureHandler.GestureHandlerRootView !== null && _reactNativeGestureHandler.GestureHandlerRootView !== void 0 ? _reactNativeGestureHandler.GestureHandlerRootView : _reactNative.View;
/**
 * Component that renders the drawer.
 */

function DrawerView(_ref2) {
  let {
    state,
    navigation,
    descriptors,
    lazy = true,
    drawerContent = props => React.createElement(_DrawerContent.default, props),
    drawerPosition = _reactNative.I18nManager.isRTL ? 'right' : 'left',
    keyboardDismissMode = 'on-drag',
    overlayColor = 'rgba(0, 0, 0, 0.5)',
    drawerType = 'front',
    hideStatusBar = false,
    statusBarAnimation = 'slide',
    drawerContentOptions,
    drawerStyle,
    edgeWidth,
    gestureHandlerProps,
    minSwipeDistance,
    sceneContainerStyle
  } = _ref2;
  const [loaded, setLoaded] = React.useState([state.index]);
  const [drawerWidth, setDrawerWidth] = React.useState(() => getDefaultDrawerWidth(_reactNative.Dimensions.get('window')));
  const drawerGestureRef = React.useRef(null);
  const {
    colors
  } = (0, _native.useTheme)();
  const isDrawerOpen = Boolean(state.history.find(it => it.type === 'drawer'));
  const handleDrawerOpen = React.useCallback(() => {
    navigation.dispatch(_objectSpread({}, _native.DrawerActions.openDrawer(), {
      target: state.key
    }));
  }, [navigation, state.key]);
  const handleDrawerClose = React.useCallback(() => {
    navigation.dispatch(_objectSpread({}, _native.DrawerActions.closeDrawer(), {
      target: state.key
    }));
  }, [navigation, state.key]);
  React.useEffect(() => {
    if (isDrawerOpen) {
      navigation.emit({
        type: 'drawerOpen'
      });
    } else {
      navigation.emit({
        type: 'drawerClose'
      });
    }
  }, [isDrawerOpen, navigation]);
  React.useEffect(() => {
    let subscription;

    if (isDrawerOpen) {
      // We only add the subscription when drawer opens
      // This way we can make sure that the subscription is added as late as possible
      // This will make sure that our handler will run first when back button is pressed
      subscription = _reactNative.BackHandler.addEventListener('hardwareBackPress', () => {
        handleDrawerClose();
        return true;
      });
    }

    return () => {
      var _subscription;

      return (_subscription = subscription) === null || _subscription === void 0 ? void 0 : _subscription.remove();
    };
  }, [handleDrawerClose, isDrawerOpen, navigation, state.key]);
  React.useEffect(() => {
    const updateWidth = (_ref3) => {
      let {
        window
      } = _ref3;
      setDrawerWidth(getDefaultDrawerWidth(window));
    };

    _reactNative.Dimensions.addEventListener('change', updateWidth);

    return () => _reactNative.Dimensions.removeEventListener('change', updateWidth);
  }, []);

  if (!loaded.includes(state.index)) {
    setLoaded([...loaded, state.index]);
  }

  const renderNavigationView = (_ref4) => {
    let {
      progress
    } = _ref4;
    return React.createElement(_DrawerPositionContext.default.Provider, {
      value: drawerPosition
    }, drawerContent(_objectSpread({}, drawerContentOptions, {
      progress: progress,
      state: state,
      navigation: navigation,
      descriptors: descriptors
    })));
  };

  const renderContent = () => {
    return React.createElement(_reactNativeScreens.ScreenContainer, {
      style: styles.content
    }, state.routes.map((route, index) => {
      const descriptor = descriptors[route.key];
      const {
        unmountOnBlur
      } = descriptor.options;
      const isFocused = state.index === index;

      if (unmountOnBlur && !isFocused) {
        return null;
      }

      if (lazy && !loaded.includes(index) && !isFocused) {
        // Don't render a screen if we've never navigated to it
        return null;
      }

      return React.createElement(_ResourceSavingScene.default, {
        key: route.key,
        style: [_reactNative.StyleSheet.absoluteFill, {
          opacity: isFocused ? 1 : 0
        }],
        isVisible: isFocused
      }, descriptor.render());
    }));
  };

  const activeKey = state.routes[state.index].key;
  const {
    gestureEnabled
  } = descriptors[activeKey].options;
  return React.createElement(GestureHandlerWrapper, {
    style: styles.content
  }, React.createElement(_SafeAreaProviderCompat.default, null, React.createElement(_DrawerGestureContext.default.Provider, {
    value: drawerGestureRef
  }, React.createElement(_Drawer.default, {
    open: isDrawerOpen,
    gestureEnabled: gestureEnabled,
    onOpen: handleDrawerOpen,
    onClose: handleDrawerClose,
    onGestureRef: ref => {
      // @ts-ignore
      drawerGestureRef.current = ref;
    },
    gestureHandlerProps: gestureHandlerProps,
    drawerType: drawerType,
    drawerPosition: drawerPosition,
    sceneContainerStyle: [{
      backgroundColor: colors.background
    }, sceneContainerStyle],
    drawerStyle: [{
      width: drawerWidth,
      backgroundColor: colors.card
    }, drawerStyle],
    overlayStyle: {
      backgroundColor: overlayColor
    },
    swipeEdgeWidth: edgeWidth,
    swipeDistanceThreshold: minSwipeDistance,
    hideStatusBar: hideStatusBar,
    statusBarAnimation: statusBarAnimation,
    renderDrawerContent: renderNavigationView,
    renderSceneContent: renderContent,
    keyboardDismissMode: keyboardDismissMode,
    drawerPostion: drawerPosition
  }))));
}

const styles = _reactNative.StyleSheet.create({
  content: {
    flex: 1
  }
});
//# sourceMappingURL=DrawerView.js.map